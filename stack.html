<!doctype html>
<html lang="ar">
<head>
<meta charset="utf-8"/>

<!-- âœ… Mobile / Safari -->
<meta name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"/>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

<title>STACK</title>

<style>
:root{
  --safe-top: env(safe-area-inset-top);
  --safe-left: env(safe-area-inset-left);
}

html,body{
  margin:0;
  height:100%;
  overflow:hidden;
  font-family:system-ui,-apple-system,Segoe UI,Roboto;
  background:#1f2326;
  -webkit-text-size-adjust:100%;
  overscroll-behavior:none;
  touch-action:none;
  user-select:none;
  -webkit-user-select:none;
}

/* âœ… Canvas Ø«Ø§Ø¨Øª Ù„Ù„Ø¬ÙˆØ§Ù„ */
canvas{
  display:block;
  width:100vw;
  height:100dvh;
  height:100vh;
  touch-action:none;
}

/* âœ… Ø²Ø± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© */
#homeBtn{
  position:fixed;
  top: calc(14px + var(--safe-top));
  left: calc(14px + var(--safe-left));
  z-index:20;
  appearance:none;
  border:0;
  background:rgba(255,255,255,0.12);
  color:rgba(255,255,255,0.92);
  font-weight:900;
  padding:10px 14px;
  border-radius:999px;
  cursor:pointer;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  box-shadow:0 10px 25px rgba(0,0,0,0.25);
  -webkit-tap-highlight-color: transparent;
}
#homeBtn:active{ transform: scale(.96); }
</style>
</head>

<body>
<button id="homeBtn">Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
<canvas id="c"></canvas>

<script>
/* Ø²Ø± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© */
document.getElementById("homeBtn").onclick = () => {
  window.location.href = "index.html";
};

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

/* âœ… resize Ø¯Ù‚ÙŠÙ‚ Ù„Ù„Ø¬ÙˆØ§Ù„ */
function viewportSize(){
  const vv = window.visualViewport;
  return {
    w: vv ? vv.width : window.innerWidth,
    h: vv ? vv.height : window.innerHeight
  };
}

function resize(){
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  const {w,h} = viewportSize();

  canvas.style.width = w + "px";
  canvas.style.height = h + "px";
  canvas.width = Math.floor(w * dpr);
  canvas.height = Math.floor(h * dpr);

  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(dpr, dpr);
}
window.addEventListener("resize", resize);
window.visualViewport?.addEventListener("resize", resize);
window.visualViewport?.addEventListener("scroll", resize);
resize();

/* isometric */
const COS30=0.8660254, SIN30=0.5;
function iso(x,y){ return {x:(x-y)*COS30, y:(x+y)*SIN30}; }

/* =======================
   âœ… Ø±Ø¬Ø¹Ù†Ø§ Ø§Ù„Ø­Ø¬Ù… + Ø¨Ø·Ù‘Ø£Ù†Ø§ Ø´ÙˆÙŠ + Ø¨Ø¹Ø¯Ù†Ø§ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
   ======================= */
const BASE=320;        // âœ… Ø±Ø¬Ø¹ Ø§Ù„Ø­Ø¬Ù…
const THICK=46;
const STACK_STEP=20;
const MOVE_RANGE=420;

const SPEED0=2.8;      // âœ… Ø£Ø¨Ø·Ø£ Ø´ÙˆÙŠ (ÙƒØ§Ù† 4.0)
const SPEED_INC=0.014; // âœ… Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø³Ø±Ø¹Ø© Ù…Ø¹ Ø§Ù„Ù†Ù‚Ø§Ø· Ø£Ù‡Ø¯Ù‰

const PERFECT_EPS=6, FALL_G=0.85, FALL_LIFE=85;

/* stars */
const stars=[];
function initStars(){
  stars.length=0;
  const {w,h}=viewportSize();
  const n=Math.round((w*h)/52000);
  for(let i=0;i<n;i++){
    stars.push({
      x:Math.random()*w,
      y:Math.random()*h,
      r:0.6+Math.random()*1.6,
      a:0.04+Math.random()*0.10,
      t:(Math.random()<.5?-1:1)*(0.003+Math.random()*0.008)
    });
  }
}
initStars();
addEventListener("resize", initStars);

function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function hsl(h,s,l){return `hsl(${h} ${s}% ${l}%)`; }

function drawBG(){
  const {w,h}=viewportSize();
  const g=ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,"#23272b");
  g.addColorStop(1,"#15181b");
  ctx.fillStyle=g;
  ctx.fillRect(0,0,w,h);

  for(const s of stars){
    s.a+=s.t;
    if(s.a>0.18||s.a<0.03) s.t*=-1;
    ctx.fillStyle=`rgba(255,255,255,${s.a})`;
    ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill();
  }
}

/* ===== Ø±Ø³Ù… Ø¨Ù„ÙˆÙƒ ===== */
function drawBlock(wx,wy,w,d,level,hue,light,drop=0){
  const x0=wx-w/2, x1=wx+w/2;
  const y0=wy-d/2, y1=wy+d/2;

  const A=iso(x0,y0), B=iso(x1,y0), C=iso(x1,y1), D=iso(x0,y1);
  const lift = level*STACK_STEP;

  const baseA={x:A.x, y:A.y - lift + drop};
  const baseB={x:B.x, y:B.y - lift + drop};
  const baseC={x:C.x, y:C.y - lift + drop};
  const baseD={x:D.x, y:D.y - lift + drop};

  const topA ={x:baseA.x, y:baseA.y - THICK};
  const topB ={x:baseB.x, y:baseB.y - THICK};
  const topC ={x:baseC.x, y:baseC.y - THICK};
  const topD ={x:baseD.x, y:baseD.y - THICK};

  const cTop = hsl(hue, 42, light);
  const cR   = hsl(hue, 42, clamp(light-8, 0, 100));
  const cL   = hsl(hue, 42, clamp(light-14, 0, 100));

  // right face
  ctx.beginPath();
  ctx.moveTo(topB.x, topB.y);
  ctx.lineTo(topC.x, topC.y);
  ctx.lineTo(baseC.x, baseC.y);
  ctx.lineTo(baseB.x, baseB.y);
  ctx.closePath();
  ctx.fillStyle=cR; ctx.fill();

  // left face
  ctx.beginPath();
  ctx.moveTo(topD.x, topD.y);
  ctx.lineTo(topC.x, topC.y);
  ctx.lineTo(baseC.x, baseC.y);
  ctx.lineTo(baseD.x, baseD.y);
  ctx.closePath();
  ctx.fillStyle=cL; ctx.fill();

  // top
  ctx.beginPath();
  ctx.moveTo(topA.x, topA.y);
  ctx.lineTo(topB.x, topB.y);
  ctx.lineTo(topC.x, topC.y);
  ctx.lineTo(topD.x, topD.y);
  ctx.closePath();
  ctx.fillStyle=cTop; ctx.fill();
}

/* ===== Game state ===== */
const bestKey="stack_best_v1";
let best=Number(localStorage.getItem(bestKey)||0);

let blocks=[], falling=[], moving=null;
let score=0, over=true;
let camOffX=0, camOffY=0;
let perfectTimer=0;

function updateCamera(){
  const top=blocks[blocks.length-1];
  camOffX=-top.x;
  camOffY=-top.y;
}

function overlap1D(c1,s1,c2,s2){
  return Math.min(c1+s1/2,c2+s2/2)-Math.max(c1-s1/2,c2-s2/2);
}
function cut1D(mC,mS,tC,tS){
  const mA=mC-mS/2, mB=mC+mS/2;
  const tA=tC-tS/2, tB=tC+tS/2;
  const kA=Math.max(mA,tA), kB=Math.min(mB,tB);
  const keptSize=Math.max(0,kB-kA);
  const keptCenter=(kA+kB)/2;

  let cutSize=0, cutCenter=0, side=0;
  if(mA<tA){cutSize=tA-mA;cutCenter=(mA+tA)/2;side=-1;}
  else if(mB>tB){cutSize=mB-tB;cutCenter=(tB+mB)/2;side=1;}
  return {keptCenter, keptSize, cutCenter, cutSize, side};
}

function spawnNext(){
  const top=blocks[blocks.length-1];
  const axis=(blocks.length%2===0)?"x":"y";
  const speed=SPEED0+score*SPEED_INC;

  moving={axis,x:top.x,y:top.y,w:top.w,d:top.d,dir:1,speed,range:MOVE_RANGE};

  if(axis==="x") moving.x=top.x-moving.range;
  else moving.y=top.y-moving.range;
}

function spawnFalling(x,y,w,d,axis,side){
  falling.push({x,y,w,d,vx:axis==="x"?0:side*5.6,vy:axis==="y"?0:side*5.6,vz:0,drop:0,life:0});
}

function endGame(){
  over=true;
  best=Math.max(best,score);
  localStorage.setItem(bestKey,String(best));
}

function reset(){
  blocks=[]; falling=[];
  score=0; over=false; perfectTimer=0;
  blocks.push({x:0,y:0,w:BASE,d:BASE});
  updateCamera(); spawnNext();
}

function place(){
  if(over){ reset(); return; }
  if(!moving) return;

  const top=blocks[blocks.length-1];

  if(moving.axis==="x"){
    const ov=overlap1D(moving.x,moving.w,top.x,top.w);
    if(ov<=0){ spawnFalling(moving.x,moving.y,moving.w,moving.d,"x",1); endGame(); return; }

    if(Math.abs(moving.x-top.x)<=PERFECT_EPS){ moving.x=top.x; perfectTimer=20; }

    const r=cut1D(moving.x,moving.w,top.x,top.w);
    blocks.push({x:r.keptCenter,y:top.y,w:r.keptSize,d:moving.d});
    if(r.cutSize>0) spawnFalling(r.cutCenter,top.y,r.cutSize,moving.d,"x",r.side);

  }else{
    const ov=overlap1D(moving.y,moving.d,top.y,top.d);
    if(ov<=0){ spawnFalling(moving.x,moving.y,moving.w,moving.d,"y",1); endGame(); return; }

    if(Math.abs(moving.y-top.y)<=PERFECT_EPS){ moving.y=top.y; perfectTimer=20; }

    const r=cut1D(moving.y,moving.d,top.y,top.d);
    blocks.push({x:top.x,y:r.keptCenter,w:moving.w,d:r.keptSize});
    if(r.cutSize>0) spawnFalling(top.x,r.cutCenter,moving.w,r.cutSize,"y",r.side);
  }

  score++; updateCamera(); spawnNext();
}

function drawHUD(){
  const {w,h}=viewportSize();
  ctx.textAlign="center";

  ctx.fillStyle="rgba(255,255,255,.75)";
  ctx.font="900 clamp(48px,12vw,72px) system-ui";
  ctx.fillText(score,w/2,Math.max(120,h*0.18));

  ctx.font="800 clamp(18px,5vw,26px) system-ui";
  ctx.fillStyle="rgba(255,255,255,.45)";
  ctx.fillText("ðŸ‘‘ "+best,w/2,Math.max(160,h*0.24));

  if(perfectTimer>0){
    ctx.font="900 clamp(24px,7vw,40px) system-ui";
    ctx.fillStyle="rgba(255,255,255,.65)";
    ctx.fillText("PERFECT", w/2, h*0.33);
  }

  if(over){
    ctx.font="900 clamp(18px,5vw,28px) system-ui";
    ctx.fillStyle="rgba(255,255,255,.45)";
    ctx.fillText("TAP TO RESTART", w/2, h*0.36);
  }
}

function tick(){
  if(moving && !over){
    const top=blocks[blocks.length-1];
    if(moving.axis==="x"){
      moving.x+=moving.dir*moving.speed;
      if(moving.x>top.x+MOVE_RANGE) moving.dir=-1;
      if(moving.x<top.x-MOVE_RANGE) moving.dir=1;
    }else{
      moving.y+=moving.dir*moving.speed;
      if(moving.y>top.y+MOVE_RANGE) moving.dir=-1;
      if(moving.y<top.y-MOVE_RANGE) moving.dir=1;
    }
  }

  for(let i=falling.length-1;i>=0;i--){
    const f=falling[i];
    f.x+=f.vx; f.y+=f.vy;
    f.vz+=FALL_G; f.drop+=f.vz; f.life++;
    if(f.life>FALL_LIFE) falling.splice(i,1);
  }

  if(perfectTimer>0) perfectTimer--;

  drawBG();

  const {w,h}=viewportSize();

  // âœ… Ø¨Ø¹Ø¯Ù†Ø§ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§: (ÙƒØ§Ù† 0.62)
  const follow = Math.max(0, (blocks.length - 9) * STACK_STEP);
  const cx = w/2;
  const cy = h*0.72 + follow;

  ctx.save();
  ctx.translate(cx, cy);

  const light = clamp(48 + score*0.6, 48, 70);
  const hue = 165;

  blocks.forEach((b,i)=>drawBlock(b.x+camOffX,b.y+camOffY,b.w,b.d,i,hue,light));
  if(moving) drawBlock(moving.x+camOffX,moving.y+camOffY,moving.w,moving.d,blocks.length,hue,light);
  for(const f of falling){
    drawBlock(f.x+camOffX,f.y+camOffY,f.w,f.d,blocks.length,hue,light,f.drop);
  }

  ctx.restore();
  drawHUD();

  requestAnimationFrame(tick);
}

addEventListener("pointerdown", e=>{ e.preventDefault(); place(); }, {passive:false});
addEventListener("keydown", e=>{ if(e.code==="Space") place(); });

requestAnimationFrame(tick);
</script>
</body>
</html>
